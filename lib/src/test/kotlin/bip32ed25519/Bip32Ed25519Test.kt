/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package bip32ed25519

import cash.z.ecc.android.bip39.Mnemonics.MnemonicCode
import cash.z.ecc.android.bip39.toSeed
import com.goterl.lazysodium.utils.Key
import java.util.Base64
import kotlin.collections.component1
import kotlin.test.Test
import kotlin.test.assertNotEquals
import net.pwall.json.schema.JSONSchema
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance

/*
 * Helper function to convert a string of comma separated numbers to a byte array (
 * to save space as linter keeps placing each array value on a single row)
 */
fun helperStringToByteArray(input: String): ByteArray {
        return input.split(",")
                        .map { it.trim().toInt() }
                        .toIntArray()
                        .map { it.toByte() }
                        .toByteArray()
}

class Bip32Ed25519Test {

        @TestInstance(TestInstance.Lifecycle.PER_CLASS)
        internal class KeyGenTests {

                private lateinit var c: Bip32Ed25519

                @BeforeAll
                fun setup() {
                        val seed =
                                        MnemonicCode(
                                                        "salon zoo engage submit smile frost later decide wing sight chaos renew lizard rely canal coral scene hobby scare step bus leaf tobacco slice".toCharArray()
                                        )
                        c = Bip32Ed25519(seed.toSeed())
                }

                @Test
                fun hardenTest() {
                        assert(Bip32Ed25519.harden(0u) == 2147483648u) {
                                "harden(0) and 2147483648 are not equal"
                        }
                        assert(Bip32Ed25519.harden(1u) == 2147483649u) {
                                "harden(1) and 2147483648 are not equal"
                        }
                        assert(Bip32Ed25519.harden(44u) == 2147483692u) {
                                "harden(44) and 2147483648 are not equal"
                        }
                        assert(Bip32Ed25519.harden(283u) == 2147483931u) {
                                "harden(283) and 2147483648 are not equal"
                        }
                }

                @Test
                fun deriveNonHardenedTest() {
                        val kl =
                                        helperStringToByteArray(
                                                        "168,186,128,2,137,34,217,252,250,5,92,120,174,222,85,181,197,117,188,216,213,165,49,104,237,244,95,54,217,236,143,70"
                                        )
                        val cc =
                                        helperStringToByteArray(
                                                        "121,107,146,6,236,48,225,66,233,75,121,10,152,128,91,249,153,4,43,85,4,105,99,23,78,230,206,226,208,55,89,70"
                                        )
                        val index = 0u

                        val deriveNonHardenedExpectedOutcomeZZ =
                                        helperStringToByteArray(
                                                        "79,57,235,234,215,9,72,57,157,32,34,226,81,95,29,115,250,66,232,187,16,193,209,254,140,127,122,242,224,69,122,166,31,223,82,170,49,164,3,115,96,128,159,63,116,37,118,15,167,94,148,38,50,10,126,70,3,86,36,78,199,91,146,54"
                                        )
                        val deriveNonHardenedExpectedOutcomeChildChainCode =
                                        helperStringToByteArray(
                                                        "98,42,235,140,228,232,27,136,136,143,220,220,32,187,77,47,254,209,231,13,224,226,108,113,167,234,93,101,160,32,37,152,216,141,148,178,77,222,78,201,150,148,186,65,223,76,237,113,104,229,170,167,224,222,193,99,251,94,222,14,82,185,232,206"
                                        )

                        val (zProduced, cccProduced) = c.deriveNonHardened(kl, cc, index)

                        assert(zProduced.contentEquals(deriveNonHardenedExpectedOutcomeZZ)) {
                                "zProduced and deriveNonHardenedExpectedOutcomeZZ are not equal"
                        }

                        assert(
                                        cccProduced.contentEquals(
                                                        deriveNonHardenedExpectedOutcomeChildChainCode
                                        )
                        ) {
                                "ccProduced and deriveNonHardenedExpectedOutcomeChainCode are not equal"
                        }
                }

                @Test
                fun derivedHardenedTest() {
                        val kl =
                                        helperStringToByteArray(
                                                        "168,186,128,2,137,34,217,252,250,5,92,120,174,222,85,181,197,117,188,216,213,165,49,104,237,244,95,54,217,236,143,70"
                                        )

                        val kr =
                                        helperStringToByteArray(
                                                        "148,89,43,75,200,146,144,117,131,226,38,105,236,223,27,4,9,169,243,189,85,73,242,221,117,27,81,54,9,9,205,5"
                                        )

                        val cc =
                                        helperStringToByteArray(
                                                        "121,107,146,6,236,48,225,66,233,75,121,10,152,128,91,249,153,4,43,85,4,105,99,23,78,230,206,226,208,55,89,70"
                                        )

                        val index = Bip32Ed25519.harden(44u)

                        val deriveHardenedExpectedOutcomeZZ =
                                        helperStringToByteArray(
                                                        "241,155,222,63,177,102,52,174,88,241,56,59,144,16,74,143,9,66,66,43,208,144,253,154,211,54,107,135,59,57,54,101,184,111,121,207,178,74,118,177,0,10,69,137,96,97,246,116,206,37,118,201,90,48,254,232,249,234,191,143,116,13,40,109"
                                        )
                        val deriveHardenedExpectedOutcomeChildChainCode =
                                        helperStringToByteArray(
                                                        "113,159,183,57,127,174,86,11,68,82,114,215,136,191,242,88,45,11,66,160,140,77,60,25,130,238,210,239,247,55,117,240,141,123,149,66,11,250,54,180,175,41,166,195,76,15,154,235,246,49,203,70,79,22,94,165,138,89,21,152,23,108,180,148"
                                        )

                        val (zProduced, cccProduced) = c.deriveHardened(kl, kr, cc, index)

                        assert(zProduced.contentEquals(deriveHardenedExpectedOutcomeZZ)) {
                                "zProduced and deriveHardenedExpectedOutcomeZZ are not equal"
                        }

                        assert(
                                        cccProduced.contentEquals(
                                                        deriveHardenedExpectedOutcomeChildChainCode
                                        )
                        ) {
                                "ccProduced and deriveHardenedExpectedOutcomeChildChainCode are not equal"
                        }
                }

                @Test
                fun keyGenAcc00Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "98,254,131,43,122,209,5,68,190,131,55,166,112,67,94,80,100,174,74,102,231,123,215,137,9,118,91,70,181,118,166,243"
                                        )
                        // derive key m'/44'/283'/0'/0/0"
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 0u, 0u, 0u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc01Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "83,4,97,0,46,172,206,192,199,181,121,89,37,170,16,74,127,180,95,133,239,10,169,91,187,91,233,59,111,133,55,173"
                                        )
                        // derive key m'/44'/283'/0'/0/1"
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 0u, 0u, 1u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc02Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "34,129,200,27,238,4,238,3,159,164,130,194,131,84,28,106,176,108,131,36,219,111,28,197,156,104,37,46,29,88,188,179"
                                        )
                        // derive key m'/44'/283'/0'/0/2
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 0u, 0u, 2u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc10Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "158,18,100,63,108,0,104,220,245,59,4,218,206,214,248,193,169,10,210,28,149,74,102,223,65,64,215,147,3,22,106,103"
                                        )
                        // derive key m'/44'/283'/1'/0/1"
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 1u, 0u, 0u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc11Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "25,254,250,164,39,200,166,251,76,248,11,184,72,233,192,195,122,162,191,76,177,156,245,172,149,21,186,30,109,152,140,186"
                                        )
                        // derive key m'/44'/283'/1'/0/1"
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 1u, 0u, 1u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc21Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "138,93,223,98,213,26,44,80,229,29,186,212,99,67,86,204,114,49,74,129,237,217,23,172,145,218,150,71,122,159,181,176"
                                        )
                        // derive key m'/44'/283'/2'/0/1
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 2u, 0u, 1u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenAcc30Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "35,88,224,242,180,101,171,62,143,85,19,157,131,22,101,77,75,227,158,187,34,54,125,54,64,159,208,42,32,176,224,23"
                                        )
                        // derive key m'/44'/283'/3'/0/0"
                        val derivedPublicKey = c.keyGen(KeyContext.Address, 3u, 0u, 0u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId00Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "182,215,238,165,175,10,216,62,223,67,64,101,158,114,240,234,43,69,102,222,31,195,182,58,64,164,37,170,190,190,94,73"
                                        )
                        // derive key m'/44'/0'/0'/0/0
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 0u, 0u, 0u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId01Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "181,206,198,118,197,162,18,158,209,190,66,35,162,112,36,57,187,178,70,47,215,123,67,242,126,47,121,253,25,74,48,162"
                                        )
                        // derive key m'/44'/0'/0'/0/1
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 0u, 0u, 1u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId02Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "67,94,94,52,70,67,29,70,37,114,171,238,27,139,173,184,134,8,144,106,106,242,123,132,151,188,207,213,3,237,182,254"
                                        )

                        // derive key m'/44'/0'/0'/0/2
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 0u, 0u, 2u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId10Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "191,99,190,131,255,249,188,157,10,235,194,49,213,3,66,17,14,82,32,36,126,80,222,55,107,71,225,84,181,211,42,62"
                                        )
                        // derive key m'/44'/0'/1'/0/0
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 1u, 0u, 0u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId12Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "70,149,142,118,219,21,21,127,64,18,39,248,172,189,183,9,36,93,202,5,85,200,232,95,86,176,210,5,46,131,77,6"
                                        )
                        // derive key m'/44'/0'/1'/0/2"
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 1u, 0u, 2u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }

                @Test
                fun keyGenId21Test() {
                        val expectedKeyOutput =
                                        helperStringToByteArray(
                                                        "237,177,15,255,36,164,116,93,245,47,26,10,177,174,113,179,117,45,1,156,140,36,55,212,106,184,200,230,52,167,76,212"
                                        )
                        // derive key m'/44'/0'/2'/0/1
                        val derivedPublicKey = c.keyGen(KeyContext.Identity, 2u, 0u, 1u)
                        assert(derivedPublicKey.contentEquals(expectedKeyOutput)) {
                                "derivedPublicKey and expectedKeyOutput are not equal"
                        }
                }
        }

        @Test
        fun fromSeedBip39Test() {

                //////////
                val seed =
                                MnemonicCode(
                                                "salon zoo engage submit smile frost later decide wing sight chaos renew lizard rely canal coral scene hobby scare step bus leaf tobacco slice".toCharArray()
                                )

                assert(seed.toSeed().size == 64) { "seed size is not 64" }
                assert(
                                seed.toSeed()
                                                .contentEquals(
                                                                helperStringToByteArray(
                                                                                "58,255,45,180,22,184,149,236,60,249,164,248,209,233,112,188,152,25,146,14,123,244,74,94,53,4,119,175,14,245,87,177,81,27,9,134,222,191,120,221,56,199,197,32,205,68,255,124,114,49,97,143,149,142,33,239,2,80,115,58,140,25,21,234"
                                                                )
                                                )
                ) { "seed mnemonic did not give expected bip39 seed" }

                val c = Bip32Ed25519(seed.toSeed())

                val rootKey =
                                c.fromSeed(
                                                seed.toSeed()
                                ) // Need to figure out how to go from phrase/entropy to that
                val fromSeedExpectedOutput =
                                helperStringToByteArray(
                                                "168,186,128,2,137,34,217,252,250,5,92,120,174,222,85,181,197,117,188,216,213,165,49,104,237,244,95,54,217,236,143,70,148,89,43,75,200,146,144,117,131,226,38,105,236,223,27,4,9,169,243,189,85,73,242,221,117,27,81,54,9,9,205,5,121,107,146,6,236,48,225,66,233,75,121,10,152,128,91,249,153,4,43,85,4,105,99,23,78,230,206,226,208,55,89,70"
                                )

                assert(rootKey.contentEquals(fromSeedExpectedOutput)) {
                        "rootKey and fromSeedExpectedOutput are not equal"
                }

                assert(rootKey.size == 96) { "rootKey size is not 96" }
        }

        @TestInstance(TestInstance.Lifecycle.PER_CLASS)
        internal class ValidateDataTests {

                // Inspired by
                // https://github.com/algorandfoundation/ARCs/blob/d44a8e9ecb62152d419f1b4ea50d72baba6b5ba3/assets/arc-0052/contextual.api.crypto.spec.ts#L218
                // But how can that test be valid when it's a random byte? Not a JSON object?
                // TODO: Get this to work

                @Test
                fun validateNonceDataTest() {
                        val challenge =
                                        """
                        {
                                "0": 28, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }""".trimIndent()
                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")

                        val metadata = SignMetadata(Encoding.NONE, authSchema)
                        val valid = Bip32Ed25519.validateData(challenge.toByteArray(), metadata)
                        assert(valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateNonceDataBase64Test() {
                        val challenge =
                                        """
                        {
                                "0": 28, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }""".trimIndent()

                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")

                        val metadata = SignMetadata(Encoding.BASE64, authSchema)

                        val valid =
                                        Bip32Ed25519.validateData(
                                                        Base64.getEncoder()
                                                                        .encode(
                                                                                        challenge.toByteArray()
                                                                        ),
                                                        metadata
                                        )
                        assert(valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateMsgTest() {
                        val message = """{"text":"Hello World"}"""

                        val msgSchema = JSONSchema.parseFile("src/test/resources/msg.schema.json")
                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val valid = Bip32Ed25519.validateData(message.toByteArray(), metadata)
                        assert(valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateMsgBase64Test() {
                        val message = """{"text":"Hello World"}"""

                        val msgSchema = JSONSchema.parseFile("src/test/resources/msg.schema.json")
                        val metadata = SignMetadata(Encoding.BASE64, msgSchema)

                        val valid =
                                        Bip32Ed25519.validateData(
                                                        Base64.getEncoder()
                                                                        .encode(
                                                                                        message.toByteArray()
                                                                        ),
                                                        metadata
                                        )
                        assert(valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateInvalidNonceDataTest() {
                        // make one value larger than 255, the max according to the schema
                        val challenge =
                                        """
                        {
                                "0": 256, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }""".trimIndent()

                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")

                        val metadata = SignMetadata(Encoding.NONE, authSchema)

                        val valid = Bip32Ed25519.validateData(challenge.toByteArray(), metadata)
                        assert(!valid) { "validation failed, message not in line with schema" }
                }
                @Test
                fun validateMsgBase64WrongEncodingFailedTest() {
                        // Message is encoded as Base64, but Encoding is set to NONE

                        val message = """{"text":"Hello World"}"""
                        val jsonSchema =
                                        """
                        {
                                "type": "object",
                                "properties": {
                                        "text": {
                                                "type": "string"
                                        }
                                },
                                "required": ["text"]
                        }
                        """.trimIndent()

                        val msgSchema = JSONSchema.parse(jsonSchema)

                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val valid =
                                        Bip32Ed25519.validateData(
                                                        Base64.getEncoder()
                                                                        .encode(
                                                                                        message.toByteArray()
                                                                        ),
                                                        metadata
                                        )
                        assert(!valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateMsgWrongMessageFailedTest() {
                        // Schema expects "text" but message has "sentence" field name

                        val message = """{"sentence":"Hello World"}"""
                        val jsonSchema =
                                        """
                        {
                                "type": "object",
                                "properties": {
                                        "text": {
                                                "type": "string"
                                        }
                                },
                                "required": ["text"]
                        }
                        """.trimIndent()

                        val msgSchema = JSONSchema.parse(jsonSchema)

                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val valid = Bip32Ed25519.validateData(message.toByteArray(), metadata)
                        assert(!valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateMsgMissingFieldFailedTest() {
                        // Schema requires

                        val message = """{"text":"Hello World"}"""
                        val jsonSchema =
                                        """
                        {
                                "type": "object",
                                "properties": {
                                        "text": {
                                                "type": "string"
                                        },
                                        "i": {
                                                "type": "integer"
                                        }
                                },
                                "required": ["i"]
                        }
                        """.trimIndent()

                        val msgSchema = JSONSchema.parse(jsonSchema)

                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val valid = Bip32Ed25519.validateData(message.toByteArray(), metadata)
                        assert(!valid) { "validation failed, message not in line with schema" }
                }

                @Test
                fun validateMsgExtraFieldFailedTest() {
                        // Extra fields in message

                        val message =
                                        """{"text":"Hello World", "i": 10, "extra0": "test", "extra1": "test", "extra2": "test"}"""
                        val jsonSchema =
                                        """
                        {
                                "type": "object",
                                "properties": {
                                        "text": {
                                                "type": "string"
                                        },
                                        "i": {
                                                "type": "integer"
                                        }
                                },
                                "required": ["text", "i"]
                        }
                        """.trimIndent()

                        val msgSchema = JSONSchema.parse(jsonSchema)

                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val valid = Bip32Ed25519.validateData(message.toByteArray(), metadata)
                        assert(valid) { "validation failed, message not in line with schema" }
                }
        }

        @TestInstance(TestInstance.Lifecycle.PER_CLASS)
        internal class SignTypedDataTests {
                private lateinit var c: Bip32Ed25519

                @BeforeAll
                fun setup() {
                        val seed =
                                        MnemonicCode(
                                                        "salon zoo engage submit smile frost later decide wing sight chaos renew lizard rely canal coral scene hobby scare step bus leaf tobacco slice".toCharArray()
                                        )
                        c = Bip32Ed25519(seed.toSeed())
                }

                @Test
                fun simpleSignDataTest() {
                        // Message to sign

                        val data = """{"text":"Hello, World!"}""".trimIndent().toByteArray()

                        val pk = c.keyGen(KeyContext.Address, 0u, 0u, 0u)

                        val msgSchema = JSONSchema.parseFile("src/test/resources/msg.schema.json")
                        val metadata = SignMetadata(Encoding.NONE, msgSchema)

                        val signature = c.signData(KeyContext.Address, 0u, 0u, 0u, data, metadata)

                        val isValid = c.verifyWithPublicKey(signature, data, pk)
                        assert(isValid) { "signature is not valid" }

                        val pk2 = c.keyGen(KeyContext.Address, 0u, 0u, 1u)
                        assert(!c.verifyWithPublicKey(signature, data, pk2)) {
                                "signature is unexpectedly valid"
                        }
                }

                @Test
                fun signAuthChallengeTest() {
                        // Randomly generated 32 length byteArray

                        val data =
                                        """
                        {
                                "0": 255, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }"""
                                                        .trimIndent()
                                                        .toByteArray()

                        val pk = c.keyGen(KeyContext.Address, 0u, 0u, 0u)

                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")
                        val metadata = SignMetadata(Encoding.NONE, authSchema)

                        val signature = c.signData(KeyContext.Address, 0u, 0u, 0u, data, metadata)

                        val isValid = c.verifyWithPublicKey(signature, data, pk)
                        assert(isValid) { "signature is not valid" }

                        val pk2 = c.keyGen(KeyContext.Address, 0u, 0u, 1u)
                        assert(!c.verifyWithPublicKey(signature, data, pk2)) {
                                "signature is unexpectedly valid"
                        }
                }

                @Test
                fun signAuthChallenge64Test() {
                        // Randomly generated 32 length byteArray

                        val dataRaw =
                                        """
                        {
                                "0": 255, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }"""
                                                        .trimIndent()
                                                        .toByteArray()

                        val data = Base64.getEncoder().encode(dataRaw)
                        val pk = c.keyGen(KeyContext.Address, 0u, 0u, 0u)

                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")
                        val metadata = SignMetadata(Encoding.BASE64, authSchema)

                        val signature = c.signData(KeyContext.Address, 0u, 0u, 0u, data, metadata)

                        val isValid = c.verifyWithPublicKey(signature, data, pk)
                        assert(isValid) { "signature is not valid" }

                        val pk2 = c.keyGen(KeyContext.Address, 0u, 0u, 1u)
                        assert(!c.verifyWithPublicKey(signature, data, pk2)) {
                                "signature is unexpectedly valid"
                        }
                }

                @Test
                fun signAuthChallenge64FailedTest() {
                        // Encoding set to none despite message being Base64 encoded

                        val dataRaw =
                                        """
                        {
                                "0": 255, "1": 103, "2": 26, "3": 222, "4": 7, "5": 86, "6": 55, "7": 95, 
                                "8": 197, "9": 179, "10": 249, "11": 252, "12": 232, "13": 252, "14": 176,
                                "15": 39, "16": 112, "17": 131, "18": 52, "19": 63, "20": 212, "21": 58,
                                "22": 226, "23": 89, "24": 64, "25": 94, "26": 23, "27": 91, "28": 128,
                                "29": 143, "30": 123, "31": 27
                        }"""
                                                        .trimIndent()
                                                        .toByteArray()

                        val data = Base64.getEncoder().encode(dataRaw)

                        val authSchema =
                                        JSONSchema.parseFile("src/test/resources/auth.request.json")

                        val metadata = SignMetadata(Encoding.NONE, authSchema)

                        try {
                                c.signData(KeyContext.Address, 0u, 0u, 0u, data, metadata)
                                // If we get past this line, the test failed
                                throw (IllegalArgumentException(
                                                "signData func did not throw DataValidationExcept despite wrong encoding"
                                ))
                        } catch (e: Exception) {
                                assert(e is DataValidationException) {
                                        "signData did not throw an DataValidationException"
                                }
                        }
                }
        }

        @TestInstance(TestInstance.Lifecycle.PER_CLASS)
        internal class ECDHTests {

                private lateinit var alice: Bip32Ed25519
                private lateinit var bob: Bip32Ed25519

                @BeforeAll
                fun setup() {
                        val aliceSeed =
                                        helperStringToByteArray(
                                                        "250,218,209,237,184,13,81,24,213,243,205,138,50,233,66,156,89,25,93,27,233,217,142,232,32,9,244,213,227,226,176,97,104,107,153,85,22,65,82,124,64,137,31,205,147,48,131,90,11,121,56,111,194,192,90,135,207,74,16,171,168,84,252,76"
                                        )

                        val bobSeed =
                                        helperStringToByteArray(
                                                        "203,178,135,64,9,155,198,24,16,162,51,115,116,210,61,105,175,129,131,137,103,33,96,79,103,185,99,183,195,214,80,143,251,154,13,153,115,11,143,188,88,2,221,12,128,5,232,93,192,160,104,2,81,219,86,21,96,32,37,73,208,95,25,81"
                                        )

                        alice = Bip32Ed25519(aliceSeed)
                        bob = Bip32Ed25519(bobSeed)
                }

                @Test
                fun basicECDHTest() {
                        val aliceKey = alice.keyGen(KeyContext.Address, 0u, 0u, 0u)
                        val bobKey = bob.keyGen(KeyContext.Address, 0u, 0u, 0u)

                        val aliceSharedSecret =
                                        alice.ECDH(KeyContext.Address, 0u, 0u, 0u, bobKey, true)
                        val bobSharedSecret =
                                        bob.ECDH(KeyContext.Address, 0u, 0u, 0u, aliceKey, false)

                        assertNotEquals(
                                        aliceKey,
                                        bobKey,
                                        "alice's key and bob's key are unexpectedly equal"
                        )

                        assert(aliceSharedSecret.contentEquals(bobSharedSecret)) {
                                "aliceSharedSecret and bobSharedSecret are not equal"
                        }

                        assert(
                                        aliceSharedSecret.contentEquals(
                                                        helperStringToByteArray(
                                                                        "51,65,50,54,54,57,65,68,51,69,49,48,51,68,69,49,55,57,48,49,50,70,53,68,70,53,69,48,70,56,50,57,66,69,56,49,70,53,70,69,67,50,49,56,50,65,67,51,52,53,52,51,66,67,66,68,56,65,65,53,53,67,67,69"
                                                        )
                                        )
                        ) { "produced shared secret does not correspond to hardcoded secret" }

                        // Now we reverse pubkey order in concatenation
                        val aliceSharedSecret2 =
                                        alice.ECDH(KeyContext.Address, 0u, 0u, 0u, bobKey, false)
                        val bobSharedSecret2 =
                                        bob.ECDH(KeyContext.Address, 0u, 0u, 0u, aliceKey, true)

                        assertNotEquals(
                                        aliceSharedSecret,
                                        aliceSharedSecret2,
                                        "despite different concat orders shared secrets are equal"
                        )
                        assertNotEquals(
                                        bobSharedSecret,
                                        bobSharedSecret2,
                                        "despite different concat orders shared secrets are equal"
                        )

                        assert(aliceSharedSecret2.contentEquals(bobSharedSecret2)) {
                                "aliceSharedSecret and bobSharedSecret are not equal"
                        }

                        assert(
                                        aliceSharedSecret2.contentEquals(
                                                        helperStringToByteArray(
                                                                        "70,50,69,69,67,54,50,68,65,54,70,68,52,50,70,57,52,49,67,49,70,67,68,65,65,56,53,56,53,54,54,49,66,66,70,66,56,49,48,48,53,55,67,57,66,68,48,50,68,56,57,65,70,49,51,67,48,66,67,69,55,57,56,56"
                                                        )
                                        )
                        ) {
                                "produced second shared secret does not correspond to hardcoded secret"
                        }
                }

                @Test
                fun encryptDecryptECDHTest() {
                        val aliceKey = alice.keyGen(KeyContext.Address, 0u, 0u, 0u)
                        val bobKey = bob.keyGen(KeyContext.Address, 0u, 0u, 0u)

                        val aliceSharedSecret =
                                        Key.fromBytes(
                                                        alice.ECDH(
                                                                        KeyContext.Address,
                                                                        0u,
                                                                        0u,
                                                                        0u,
                                                                        bobKey,
                                                                        true
                                                        )
                                        )
                        val bobSharedSecret =
                                        Key.fromBytes(
                                                        bob.ECDH(
                                                                        KeyContext.Address,
                                                                        0u,
                                                                        0u,
                                                                        0u,
                                                                        aliceKey,
                                                                        false
                                                        )
                                        )

                        assert(aliceSharedSecret.asBytes.contentEquals(bobSharedSecret.asBytes)) {
                                "aliceSharedSecret and bobSharedSecret are equal"
                        }

                        val message = "Hello World"
                        val nonce =
                                        helperStringToByteArray(
                                                        "16,197,142,8,174,91,118,244,202,136,43,200,97,242,104,99,42,154,191,32,67,30,6,123"
                                        )

                        // Encrypt
                        val ciphertext =
                                        alice.lazySodium.cryptoSecretBoxEasy(
                                                        message,
                                                        nonce,
                                                        aliceSharedSecret
                                        )

                        // Decrypt
                        val plaintext =
                                        alice.lazySodium.cryptoSecretBoxOpenEasy(
                                                        ciphertext,
                                                        nonce,
                                                        aliceSharedSecret
                                        )

                        assert(
                                        ciphertext.equals(
                                                        "6E010FCA6C350392DC4893D148D77A788AA35638CB2A6341A0E5A4"
                                        ),
                        ) {
                                "produced ciphertext is not what was expected given hardcoded keys, nonce and 'Hello World' message"
                        }

                        assert(message.contentEquals(plaintext)) {
                                "message and decrypted plaintext are not equal"
                        }
                }
        }
}
